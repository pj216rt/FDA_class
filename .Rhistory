#computing coefficients
scores <- F.centered %*% (psi * dt)
#getting into the plotting mechanisms now
#plot, want plot of mean function
df_mu <- data.frame(t = as.vector(t), mu = mu)
mean_plot <- ggplot(df_mu, aes(x = t, y = mu)) +
geom_line(linewidth = 1) +
labs(title = "Mean Function", x = "t", y = "Mean f(t)") +
theme_minimal()
print(mean_plot)
#getting the K dominant directions
psiK <- psi[, seq_len(K), drop = FALSE]
colnames(psiK) <- paste0("PC", seq_len(K))
df_psi <- data.frame(t = as.vector(t), psiK)
#pivotting longer for plotting
psi_long <- tidyr::pivot_longer(df_psi, -t, names_to = "Component", values_to = "Value")
eigen.vector_plot <- ggplot(psi_long, aes(x = t, y = Value, color = Component)) +
geom_line(linewidth = 1) +
labs(title = paste0("Leading Eigenfunctions (Top ", K, ")"),
x = "t", y = "Eigenfunction Value") +
theme_minimal()
print(eigen.vector_plot)
#scree plot
df_lambda <- data.frame(Index = seq_along(lambda), Eigenvalue = lambda)
scree_plot <- ggplot(df_lambda, aes(x = Index, y = Eigenvalue)) +
geom_point(size = 2) +
geom_line() +
labs(title = "Eigenvalues (Scree Plot)", x = "Component", y = "Eigenvalue") +
theme_minimal()
print(scree_plot)
#print the variance explained by the K PCs
total_var <- sum(lambda)
pve <- lambda / total_var
cum_pve <- cumsum(pve)
cat("\nProportion of Variance Explained (PVE):\n")
cat(paste(sprintf("  PC%-2d: %6.2f%%   |  Cumulative: %6.2f%%",
1:K, 100*pve[1:K], 100*cum_pve[1:K]),
collapse = "\n"), "\n\n")
#doing the correlation plot
scores_df <- as.data.frame(scores[, seq_len(K), drop = FALSE])
colnames(scores_df) <- paste0("Coefficient:", seq_len(K))
top_coef <- ggpairs(scores_df, title = paste("Pairwise Scatter of Top", K, "FPCA Coefficients"))
print(top_coef)
}
#read in data
#dataset 1
prob4.dat.1 <- readMat("Datasets/HW1/Problem 4/DataFile1_0_1.mat")
#implementing FPCA.  Need to center the functions
Fmatrix <- prob4.dat.1$f
ts <- prob4.dat.1$t
prob4.ques1 <- fpca_cust(F = Fmatrix, t = ts)
#Problem 4
#Write code to do FPCA
fpca_cust <- function(F, t, K = 3){
#center the functional data
mu <- colMeans(F)
mu.fun.mat <- matrix(mu, nrow = nrow(F), ncol = ncol(F), byrow = TRUE)
F.centered <- F - mu
#assuming evenly spaced time points
dt <- diff(as.vector(t))[1]
# #estimating covariance operator
# n <- nrow(F.centered)
# C_hat <- crossprod(F.centered)*dt/n
#
# #eigen decomposition
# decomp <- eigen(C_hat, symmetric = TRUE)
# lambda <- decomp$values
# psi <- decomp$vectors
#svd decomp
n <- nrow(F.centered)
sv <- svd(F.centered/sqrt(n))
psi_raw <- sv$v
lambda  <- (sv$d)^2 * dt
print(lambda)
psi <- psi_raw
for (k in seq_len(ncol(psi))) {
nk <- sqrt(sum(psi_raw[,k]^2) * dt)
if (nk > 0) psi[,k] <- psi_raw[,k] / nk
}
#computing coefficients
scores <- F.centered %*% (psi * dt)
#getting into the plotting mechanisms now
#plot, want plot of mean function
df_mu <- data.frame(t = as.vector(t), mu = mu)
mean_plot <- ggplot(df_mu, aes(x = t, y = mu)) +
geom_line(linewidth = 1) +
labs(title = "Mean Function", x = "t", y = "Mean f(t)") +
theme_minimal()
print(mean_plot)
#getting the K dominant directions
psiK <- psi[, seq_len(K), drop = FALSE]
colnames(psiK) <- paste0("PC", seq_len(K))
df_psi <- data.frame(t = as.vector(t), psiK)
#pivotting longer for plotting
psi_long <- tidyr::pivot_longer(df_psi, -t, names_to = "Component", values_to = "Value")
eigen.vector_plot <- ggplot(psi_long, aes(x = t, y = Value, color = Component)) +
geom_line(linewidth = 1) +
labs(title = paste0("Leading Eigenfunctions (Top ", K, ")"),
x = "t", y = "Eigenfunction Value") +
theme_minimal()
print(eigen.vector_plot)
#scree plot
df_lambda <- data.frame(Index = seq_along(lambda), Eigenvalue = lambda)
scree_plot <- ggplot(df_lambda, aes(x = Index, y = Eigenvalue)) +
geom_point(size = 2) +
geom_line() +
labs(title = "Eigenvalues (Scree Plot)", x = "Component", y = "Eigenvalue") +
theme_minimal()
print(scree_plot)
#print the variance explained by the K PCs
total_var <- sum(lambda)
pve <- lambda / total_var
cum_pve <- cumsum(pve)
cat("\nProportion of Variance Explained (PVE):\n")
cat(paste(sprintf("  PC%-2d: %6.2f%%   |  Cumulative: %6.2f%%",
1:K, 100*pve[1:K], 100*cum_pve[1:K]),
collapse = "\n"), "\n\n")
#doing the correlation plot
scores_df <- as.data.frame(scores[, seq_len(K), drop = FALSE])
colnames(scores_df) <- paste0("Coefficient:", seq_len(K))
top_coef <- ggpairs(scores_df, title = paste("Pairwise Scatter of Top", K, "FPCA Coefficients"))
print(top_coef)
}
#read in data
#dataset 1
prob4.dat.1 <- readMat("Datasets/HW1/Problem 4/DataFile1_0_1.mat")
#implementing FPCA.  Need to center the functions
Fmatrix <- prob4.dat.1$f
ts <- prob4.dat.1$t
prob4.ques1 <- fpca_cust(F = Fmatrix, t = ts)
#Problem 4
#Write code to do FPCA
fpca_cust <- function(F, t, K = 3){
#center the functional data
mu <- colMeans(F)
mu.fun.mat <- matrix(mu, nrow = nrow(F), ncol = ncol(F), byrow = TRUE)
F.centered <- F - mu
#assuming evenly spaced time points
dt <- diff(as.vector(t))[1]
# #estimating covariance operator
# n <- nrow(F.centered)
# C_hat <- crossprod(F.centered)*dt/n
#
# #eigen decomposition
# decomp <- eigen(C_hat, symmetric = TRUE)
# lambda <- decomp$values
# psi <- decomp$vectors
#svd decomp
n <- nrow(F.centered)
sv <- svd(F.centered/sqrt(n))
psi_raw <- sv$v
lambda  <- (sv$d)^2 * dt
print(round(lambda[1:min(10, length(lambda))], 6))
psi <- psi_raw
for (k in seq_len(ncol(psi))) {
nk <- sqrt(sum(psi_raw[,k]^2) * dt)
if (nk > 0) psi[,k] <- psi_raw[,k] / nk
}
#computing coefficients
scores <- F.centered %*% (psi * dt)
#getting into the plotting mechanisms now
#plot, want plot of mean function
df_mu <- data.frame(t = as.vector(t), mu = mu)
mean_plot <- ggplot(df_mu, aes(x = t, y = mu)) +
geom_line(linewidth = 1) +
labs(title = "Mean Function", x = "t", y = "Mean f(t)") +
theme_minimal()
print(mean_plot)
#getting the K dominant directions
psiK <- psi[, seq_len(K), drop = FALSE]
colnames(psiK) <- paste0("PC", seq_len(K))
df_psi <- data.frame(t = as.vector(t), psiK)
#pivotting longer for plotting
psi_long <- tidyr::pivot_longer(df_psi, -t, names_to = "Component", values_to = "Value")
eigen.vector_plot <- ggplot(psi_long, aes(x = t, y = Value, color = Component)) +
geom_line(linewidth = 1) +
labs(title = paste0("Leading Eigenfunctions (Top ", K, ")"),
x = "t", y = "Eigenfunction Value") +
theme_minimal()
print(eigen.vector_plot)
#scree plot
df_lambda <- data.frame(Index = seq_along(lambda), Eigenvalue = lambda)
scree_plot <- ggplot(df_lambda, aes(x = Index, y = Eigenvalue)) +
geom_point(size = 2) +
geom_line() +
labs(title = "Eigenvalues (Scree Plot)", x = "Component", y = "Eigenvalue") +
theme_minimal()
print(scree_plot)
#print the variance explained by the K PCs
total_var <- sum(lambda)
pve <- lambda / total_var
cum_pve <- cumsum(pve)
cat("\nProportion of Variance Explained (PVE):\n")
cat(paste(sprintf("  PC%-2d: %6.2f%%   |  Cumulative: %6.2f%%",
1:K, 100*pve[1:K], 100*cum_pve[1:K]),
collapse = "\n"), "\n\n")
#doing the correlation plot
scores_df <- as.data.frame(scores[, seq_len(K), drop = FALSE])
colnames(scores_df) <- paste0("Coefficient:", seq_len(K))
top_coef <- ggpairs(scores_df, title = paste("Pairwise Scatter of Top", K, "FPCA Coefficients"))
print(top_coef)
}
prob4.ques1 <- fpca_cust(F = Fmatrix, t = ts)
#Problem 4
#Write code to do FPCA
fpca_cust <- function(F, t, K = 3){
#center the functional data
mu <- colMeans(F)
mu.fun.mat <- matrix(mu, nrow = nrow(F), ncol = ncol(F), byrow = TRUE)
F.centered <- F - mu
#assuming evenly spaced time points
dt <- diff(as.vector(t))[1]
# #estimating covariance operator
# n <- nrow(F.centered)
# C_hat <- crossprod(F.centered)*dt/n
#
# #eigen decomposition
# decomp <- eigen(C_hat, symmetric = TRUE)
# lambda <- decomp$values
# psi <- decomp$vectors
#svd decomp
n <- nrow(F.centered)
sv <- svd(F.centered/sqrt(n))
psi_raw <- sv$v
lambda  <- (sv$d)^2 * dt
print(round(lambda[1:min(25, length(lambda))], 6))
psi <- psi_raw
for (k in seq_len(ncol(psi))) {
nk <- sqrt(sum(psi_raw[,k]^2) * dt)
if (nk > 0) psi[,k] <- psi_raw[,k] / nk
}
#computing coefficients
scores <- F.centered %*% (psi * dt)
#getting into the plotting mechanisms now
#plot, want plot of mean function
df_mu <- data.frame(t = as.vector(t), mu = mu)
mean_plot <- ggplot(df_mu, aes(x = t, y = mu)) +
geom_line(linewidth = 1) +
labs(title = "Mean Function", x = "t", y = "Mean f(t)") +
theme_minimal()
print(mean_plot)
#getting the K dominant directions
psiK <- psi[, seq_len(K), drop = FALSE]
colnames(psiK) <- paste0("PC", seq_len(K))
df_psi <- data.frame(t = as.vector(t), psiK)
#pivotting longer for plotting
psi_long <- tidyr::pivot_longer(df_psi, -t, names_to = "Component", values_to = "Value")
eigen.vector_plot <- ggplot(psi_long, aes(x = t, y = Value, color = Component)) +
geom_line(linewidth = 1) +
labs(title = paste0("Leading Eigenfunctions (Top ", K, ")"),
x = "t", y = "Eigenfunction Value") +
theme_minimal()
print(eigen.vector_plot)
#scree plot
df_lambda <- data.frame(Index = seq_along(lambda), Eigenvalue = lambda)
scree_plot <- ggplot(df_lambda, aes(x = Index, y = Eigenvalue)) +
geom_point(size = 2) +
geom_line() +
labs(title = "Eigenvalues (Scree Plot)", x = "Component", y = "Eigenvalue") +
theme_minimal()
print(scree_plot)
#print the variance explained by the K PCs
total_var <- sum(lambda)
pve <- lambda / total_var
cum_pve <- cumsum(pve)
cat("\nProportion of Variance Explained (PVE):\n")
cat(paste(sprintf("  PC%-2d: %6.2f%%   |  Cumulative: %6.2f%%",
1:K, 100*pve[1:K], 100*cum_pve[1:K]),
collapse = "\n"), "\n\n")
#doing the correlation plot
scores_df <- as.data.frame(scores[, seq_len(K), drop = FALSE])
colnames(scores_df) <- paste0("Coefficient:", seq_len(K))
top_coef <- ggpairs(scores_df, title = paste("Pairwise Scatter of Top", K, "FPCA Coefficients"))
print(top_coef)
}
prob4.ques1 <- fpca_cust(F = Fmatrix, t = ts)
#Problem 4
#Write code to do FPCA
fpca_cust <- function(F, t, K = 3){
#center the functional data
mu <- colMeans(F)
mu.fun.mat <- matrix(mu, nrow = nrow(F), ncol = ncol(F), byrow = TRUE)
F.centered <- F - mu
#assuming evenly spaced time points
dt <- diff(as.vector(t))[1]
# #estimating covariance operator
# n <- nrow(F.centered)
# C_hat <- crossprod(F.centered)*dt/n
#
# #eigen decomposition
# decomp <- eigen(C_hat, symmetric = TRUE)
# lambda <- decomp$values
# psi <- decomp$vectors
#svd decomp
n <- nrow(F.centered)
sv <- svd(F.centered/sqrt(n))
psi_raw <- sv$v
lambda  <- (sv$d)^2 * dt
tol <- max(lambda) * 1e-3            # relative cutoff; tweak (1e-2 stricter, 1e-4 looser)
keep <- which(lambda > tol)
if (length(keep) == 0L) keep <- 1L   # safety
lambda <- lambda[keep]
psi_raw <- psi_raw[, keep, drop = FALSE]
print(psi_raw)
psi <- psi_raw
for (k in seq_len(ncol(psi))) {
nk <- sqrt(sum(psi_raw[,k]^2) * dt)
if (nk > 0) psi[,k] <- psi_raw[,k] / nk
}
#computing coefficients
scores <- F.centered %*% (psi * dt)
#getting into the plotting mechanisms now
#plot, want plot of mean function
df_mu <- data.frame(t = as.vector(t), mu = mu)
mean_plot <- ggplot(df_mu, aes(x = t, y = mu)) +
geom_line(linewidth = 1) +
labs(title = "Mean Function", x = "t", y = "Mean f(t)") +
theme_minimal()
print(mean_plot)
#getting the K dominant directions
psiK <- psi[, seq_len(K), drop = FALSE]
colnames(psiK) <- paste0("PC", seq_len(K))
df_psi <- data.frame(t = as.vector(t), psiK)
#pivotting longer for plotting
psi_long <- tidyr::pivot_longer(df_psi, -t, names_to = "Component", values_to = "Value")
eigen.vector_plot <- ggplot(psi_long, aes(x = t, y = Value, color = Component)) +
geom_line(linewidth = 1) +
labs(title = paste0("Leading Eigenfunctions (Top ", K, ")"),
x = "t", y = "Eigenfunction Value") +
theme_minimal()
print(eigen.vector_plot)
#scree plot
df_lambda <- data.frame(Index = seq_along(lambda), Eigenvalue = lambda)
scree_plot <- ggplot(df_lambda, aes(x = Index, y = Eigenvalue)) +
geom_point(size = 2) +
geom_line() +
labs(title = "Eigenvalues (Scree Plot)", x = "Component", y = "Eigenvalue") +
theme_minimal()
print(scree_plot)
#print the variance explained by the K PCs
total_var <- sum(lambda)
pve <- lambda / total_var
cum_pve <- cumsum(pve)
cat("\nProportion of Variance Explained (PVE):\n")
cat(paste(sprintf("  PC%-2d: %6.2f%%   |  Cumulative: %6.2f%%",
1:K, 100*pve[1:K], 100*cum_pve[1:K]),
collapse = "\n"), "\n\n")
#doing the correlation plot
scores_df <- as.data.frame(scores[, seq_len(K), drop = FALSE])
colnames(scores_df) <- paste0("Coefficient:", seq_len(K))
top_coef <- ggpairs(scores_df, title = paste("Pairwise Scatter of Top", K, "FPCA Coefficients"))
print(top_coef)
}
prob4.ques1 <- fpca_cust(F = Fmatrix, t = ts)
#Problem 4
#Write code to do FPCA
fpca_cust <- function(F, t, K = 3){
#center the functional data
mu <- colMeans(F)
mu.fun.mat <- matrix(mu, nrow = nrow(F), ncol = ncol(F), byrow = TRUE)
F.centered <- F - mu
#assuming evenly spaced time points
dt <- diff(as.vector(t))[1]
# #estimating covariance operator
# n <- nrow(F.centered)
# C_hat <- crossprod(F.centered)*dt/n
#
# #eigen decomposition
# decomp <- eigen(C_hat, symmetric = TRUE)
# lambda <- decomp$values
# psi <- decomp$vectors
#svd decomp
n <- nrow(F.centered)
sv <- svd(F.centered/sqrt(n))
psi_raw <- sv$v
lambda  <- (sv$d)^2 * dt
tol <- max(lambda) * 1e-3            # relative cutoff; tweak (1e-2 stricter, 1e-4 looser)
keep <- which(lambda > tol)
if (length(keep) == 0L) keep <- 1L   # safety
lambda <- lambda[keep]
psi_raw <- psi_raw[, keep, drop = FALSE]
print(lambda)
psi <- psi_raw
for (k in seq_len(ncol(psi))) {
nk <- sqrt(sum(psi_raw[,k]^2) * dt)
if (nk > 0) psi[,k] <- psi_raw[,k] / nk
}
#computing coefficients
scores <- F.centered %*% (psi * dt)
#getting into the plotting mechanisms now
#plot, want plot of mean function
df_mu <- data.frame(t = as.vector(t), mu = mu)
mean_plot <- ggplot(df_mu, aes(x = t, y = mu)) +
geom_line(linewidth = 1) +
labs(title = "Mean Function", x = "t", y = "Mean f(t)") +
theme_minimal()
print(mean_plot)
#getting the K dominant directions
psiK <- psi[, seq_len(K), drop = FALSE]
colnames(psiK) <- paste0("PC", seq_len(K))
df_psi <- data.frame(t = as.vector(t), psiK)
#pivotting longer for plotting
psi_long <- tidyr::pivot_longer(df_psi, -t, names_to = "Component", values_to = "Value")
eigen.vector_plot <- ggplot(psi_long, aes(x = t, y = Value, color = Component)) +
geom_line(linewidth = 1) +
labs(title = paste0("Leading Eigenfunctions (Top ", K, ")"),
x = "t", y = "Eigenfunction Value") +
theme_minimal()
print(eigen.vector_plot)
#scree plot
df_lambda <- data.frame(Index = seq_along(lambda), Eigenvalue = lambda)
scree_plot <- ggplot(df_lambda, aes(x = Index, y = Eigenvalue)) +
geom_point(size = 2) +
geom_line() +
labs(title = "Eigenvalues (Scree Plot)", x = "Component", y = "Eigenvalue") +
theme_minimal()
print(scree_plot)
#print the variance explained by the K PCs
total_var <- sum(lambda)
pve <- lambda / total_var
cum_pve <- cumsum(pve)
cat("\nProportion of Variance Explained (PVE):\n")
cat(paste(sprintf("  PC%-2d: %6.2f%%   |  Cumulative: %6.2f%%",
1:K, 100*pve[1:K], 100*cum_pve[1:K]),
collapse = "\n"), "\n\n")
#doing the correlation plot
scores_df <- as.data.frame(scores[, seq_len(K), drop = FALSE])
colnames(scores_df) <- paste0("Coefficient:", seq_len(K))
top_coef <- ggpairs(scores_df, title = paste("Pairwise Scatter of Top", K, "FPCA Coefficients"))
print(top_coef)
}
prob4.ques1 <- fpca_cust(F = Fmatrix, t = ts)
#Problem 4
#Write code to do FPCA
fpca_cust <- function(F, t, K = 3){
#center the functional data
mu <- colMeans(F)
mu.fun.mat <- matrix(mu, nrow = nrow(F), ncol = ncol(F), byrow = TRUE)
F.centered <- F - mu
#assuming evenly spaced time points
dt <- diff(as.vector(t))[1]
#estimating covariance operator
n <- nrow(F.centered)
C_hat <- crossprod(F.centered)*dt/n
#eigen decomposition
decomp <- eigen(C_hat, symmetric = TRUE)
lambda <- decomp$values
psi <- decomp$vectors
#svd decomp
# n <- nrow(F.centered)
# sv <- svd(F.centered/sqrt(n))
# psi_raw <- sv$v
# lambda  <- (sv$d)^2 * dt
#
# psi <- psi_raw
# for (k in seq_len(ncol(psi))) {
#   nk <- sqrt(sum(psi_raw[,k]^2) * dt)
#   if (nk > 0) psi[,k] <- psi_raw[,k] / nk
# }
#computing coefficients
scores <- F.centered %*% (psi * dt)
#getting into the plotting mechanisms now
#plot, want plot of mean function
df_mu <- data.frame(t = as.vector(t), mu = mu)
mean_plot <- ggplot(df_mu, aes(x = t, y = mu)) +
geom_line(linewidth = 1) +
labs(title = "Mean Function", x = "t", y = "Mean f(t)") +
theme_minimal()
print(mean_plot)
#getting the K dominant directions
psiK <- psi[, seq_len(K), drop = FALSE]
colnames(psiK) <- paste0("PC", seq_len(K))
df_psi <- data.frame(t = as.vector(t), psiK)
#pivotting longer for plotting
psi_long <- tidyr::pivot_longer(df_psi, -t, names_to = "Component", values_to = "Value")
eigen.vector_plot <- ggplot(psi_long, aes(x = t, y = Value, color = Component)) +
geom_line(linewidth = 1) +
labs(title = paste0("Leading Eigenfunctions (Top ", K, ")"),
x = "t", y = "Eigenfunction Value") +
theme_minimal()
print(eigen.vector_plot)
#scree plot
df_lambda <- data.frame(Index = seq_along(lambda), Eigenvalue = lambda)
scree_plot <- ggplot(df_lambda, aes(x = Index, y = Eigenvalue)) +
geom_point(size = 2) +
geom_line() +
labs(title = "Eigenvalues (Scree Plot)", x = "Component", y = "Eigenvalue") +
theme_minimal()
print(scree_plot)
#print the variance explained by the K PCs
total_var <- sum(lambda)
pve <- lambda / total_var
cum_pve <- cumsum(pve)
cat("\nProportion of Variance Explained (PVE):\n")
cat(paste(sprintf("  PC%-2d: %6.2f%%   |  Cumulative: %6.2f%%",
1:K, 100*pve[1:K], 100*cum_pve[1:K]),
collapse = "\n"), "\n\n")
#doing the correlation plot
scores_df <- as.data.frame(scores[, seq_len(K), drop = FALSE])
colnames(scores_df) <- paste0("Coefficient:", seq_len(K))
top_coef <- ggpairs(scores_df, title = paste("Pairwise Scatter of Top", K, "FPCA Coefficients"))
print(top_coef)
}
prob4.ques1 <- fpca_cust(F = Fmatrix, t = ts)
library(fda)
tvec    <- as.numeric(prob4.dat.1$t)
nbasis <- 25
basis  <- create.bspline.basis(rangeval = range(tvec), nbasis = nbasis, norder = 4)
fd_raw <- Data2fd(y = t(Fmatrix), argvals = tvec, basisobj = basis)
fun_pca <- pca.fd(fd_raw, nharm = 3)
plot(fun_pca$harmonics, lwd = 3)
fun_pca$varprop
