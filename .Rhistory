L <- B_dense
#second difference penalty matrix
D2 <- diff(diag(K), differences = 2)
P  <- crossprod(D2)
#function to build continuous penalty
q6.pen <- function(K, t, M){
t_pen <- seq(t[1], t[2], length.out = M)
#getting the stepsize
h <- (t_pen[2] - t_pen[1])
#weights
w <- c(h/2, rep(h, M-2), h/2)
#get B splines and second derivatives of B splines
B2 <- bSpline(t_pen, df = K, intercept = TRUE, derivs = 2)
#initialize penalty matrix
P <- matrix(0, nrow = K, ncol = K)
#loop
for (i in 1:K) {
for (j in i:K) {
val <- sum(w * B2[, i] * B2[, j])
P[i, j] <- val
P[j, i] <- val
}
}
return(P)
}
test <- q6.pen(K=5, t = t, M = 500)
#two different penalty matrices.  One based on second differences.  The other based
#on approximating the integral
# P
# test
lambda_grid <- c(0, 0.5, 1, 5, 50, 100)
#function to fit and return CIs for one lambda
fit_one_lambda <- function(lambda) {
A <- A <- PhiT_W_Phi + (lambda*P)
S <- solve(A, PhiT_W)
#coefficients and predicted values
chat <- as.vector(S %*% y)
yhat <- as.vector(Phi %*% chat)
#degrees of freedom
Hdiag  <- rowSums(Phi * t(S))
df_eff <- sum(Hdiag)
#estimate of sigma^2
n <- nrow(Phi)
sigma2_hat <- sum((y - yhat)^2) / (n-df_eff)
#computing variance and CIS
LS <- L %*% S
beta_var <- sigma2_hat * rowSums(LS*LS)
beta_hat <- as.vector(L %*% chat)
beta_se  <- sqrt(beta_var)
#critical Z value for 95% CI
z <- qnorm(0.975)
#create dataframe for outputs
data.frame(
t        = t_dense,
beta     = beta_hat,
lo       = beta_hat - (z*beta_se),
hi       = beta_hat + (z*beta_se),
lambda   = lambda,
lambda_lab = paste0("Lambda=", lambda),
df_eff   = df_eff
)
}
df_all <- do.call(rbind, lapply(lambda_grid, fit_one_lambda))
#plot this
ggplot(df_all, aes(x = t, y = beta)) +
geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.18) +
geom_line(linewidth = 1) +
facet_wrap(~ lambda_lab, ncol = 3) +
labs(
title = expression(hat(beta)(t) ~ "with 95% pointwise CI for Penalized/Unpenalized regression"),
subtitle = "95% Confidence Intervals Shown",
x = "t",
y = expression(hat(beta)(t))
) +
theme_minimal(base_size = 14)
#basis (B-splines) and design matrix
K <- 20
B  <- bs(t, df = K, intercept = TRUE)
dt <- diff(t)[1]
#for trapezoid rule
wt_obs <- c(dt/2, rep(dt, length(t)-2), dt/2)
#trying to keep the same notation as Silverman
Phi <- Fmat %*% (B*wt_obs)
#weight matrix
W <- diag(nrow(Phi))
#precompute
PhiT_W <- t(Phi) %*% W
PhiT_W_Phi <- PhiT_W %*% Phi
t_dense <- seq(min(t), max(t), length.out = 200)
B_dense <- bs(t_dense, df = K, intercept = TRUE)
L <- B_dense
#second difference penalty matrix
D2 <- diff(diag(K), differences = 2)
P  <- crossprod(D2)
#function to build continuous penalty
q6.pen <- function(K, t, M){
t_pen <- seq(t[1], t[2], length.out = M)
#getting the stepsize
h <- (t_pen[2] - t_pen[1])
#weights
w <- c(h/2, rep(h, M-2), h/2)
#get B splines and second derivatives of B splines
B2 <- bSpline(t_pen, df = K, intercept = TRUE, derivs = 2)
#initialize penalty matrix
P <- matrix(0, nrow = K, ncol = K)
#loop
for (i in 1:K) {
for (j in i:K) {
val <- sum(w * B2[, i] * B2[, j])
P[i, j] <- val
P[j, i] <- val
}
}
return(P)
}
test <- q6.pen(K=5, t = t, M = 500)
lambda_grid <- c(0, 0.5, 1, 5, 50, 100)
#function to fit and return CIs for one lambda
fit_one_lambda <- function(lambda) {
A <- A <- PhiT_W_Phi + (lambda*P)
S <- solve(A, PhiT_W)
#coefficients and predicted values
chat <- as.vector(S %*% y)
yhat <- as.vector(Phi %*% chat)
#degrees of freedom
Hdiag  <- rowSums(Phi * t(S))
df_eff <- sum(Hdiag)
#estimate of sigma^2
n <- nrow(Phi)
sigma2_hat <- sum((y - yhat)^2) / (n-df_eff)
#computing variance and CIS
LS <- L %*% S
beta_var <- sigma2_hat * rowSums(LS*LS)
beta_hat <- as.vector(L %*% chat)
beta_se  <- sqrt(beta_var)
#critical Z value for 95% CI
z <- qnorm(0.975)
#create dataframe for outputs
data.frame(
t        = t_dense,
beta     = beta_hat,
lo       = beta_hat - (z*beta_se),
hi       = beta_hat + (z*beta_se),
lambda   = lambda,
lambda_lab = paste0("Lambda=", lambda),
df_eff   = df_eff
)
}
df_all <- do.call(rbind, lapply(lambda_grid, fit_one_lambda))
#plot this
ggplot(df_all, aes(x = t, y = beta)) +
geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.18) +
geom_line(linewidth = 1) +
facet_wrap(~ lambda_lab, ncol = 3) +
labs(
title = expression(hat(beta)(t) ~ "with 95% pointwise CI for Penalized/Unpenalized regression"),
subtitle = "95% Confidence Intervals Shown",
x = "t",
y = expression(hat(beta)(t))
) +
theme_minimal(base_size = 14)
problem2 <- function(p, q, n_steps = 1000){
#for unit vectors a,b in Hilbert space, \theta = arccos({x,y})
angle <- acos(sum(p * q))
#create matrix to hold the path
}
problem2 <- function(p, q, n_steps = 1000){
#for unit vectors a,b in Hilbert space, \theta = arccos({x,y})
angle <- acos(sum(p * q))
#create matrix to hold the path
#each row will be the path at t = n_step_i, and the length will
#correspond to the length of the vector
path <- matrix(NA, nrow = n_steps, ncol = length(p))
#computing path
for (i in 1:n_steps) {
}
}
#function to build test functions
f_t <- function(t, a, b){
part1 <- t^(a-1)
part2 <- part1*(1-t)^(b-1)
part3 <- part2/beta(a,b)
part4 <- sqrt(part3)
return(part4)
}
problem2 <- function(p, q, n_steps = 1000){
#need to rescale the points
p <- p / sqrt(sum(p^2))
q <- q / sqrt(sum(q^2))
#for unit vectors a,b in Hilbert space, \theta = arccos({x,y})
angle <- acos(sum(p * q))
#create matrix to hold the path
#each row will be the path at t = n_step_i, and the length will
#correspond to the length of the vector
path <- matrix(NA, nrow = n_steps, ncol = length(p))
#computing path, assuming that the points are not antipodal, since then any path will do.
#I think we only compute the angle once?
for (i in 1:n_steps) {
#compute time, starting at 0
t <- (i-1) / (n_steps-1)
#the first term
term1 <- sin(angle*(1-t))*p
term2 <- sin(t*angle)*q
#path at time t
combined <- (term1+term2)/sin(angle)
path[i, ] <- combined
}
#return the path
return(path)
}
time.grid <- seq(0,1,length.out = 1000)
#building points
f1 <- f_t(time.grid, a = 2, b = 5)
f2 <- f_t(time.grid, a = 2, b = 2)
num.points = 1000
time.grid <- seq(0,1,length.out = num.points)
#building points
f1 <- f_t(time.grid, a = 2, b = 5)
f2 <- f_t(time.grid, a = 2, b = 2)
test <- problem2(p=f1, q=f2)
View(test)
plot(f1)
plot(f2)
test <- problem2(p=f1, q=f2)
path <- problem2(p=f1, q=f2)
idx <- c(1, 6, 11)
plot(time.grid, path[idx[1], ], type = "l", lwd = 2,
ylim = range(path[idx, ]), xlab = "t", ylab = "f_τ(t)",
main = "Geodesic between f_{2,5} and f_{2,2}")
lines(time.grid, path[idx[2], ], lwd = 2)
lines(time.grid, path[idx[3], ], lwd = 2)
legend("topright",
legend = sprintf("τ = %.1f", (idx - 1) / (nrow(path) - 1)),
lwd = 2, bty = "n")
#plotting
plot(time.grid, f1, type = "l", lwd = 2, col = "red",
ylim = range(geo), xlab = "t", ylab = "Function value",
main = "Geodesic on unit Hilbert sphere")
#plotting
plot(time.grid, f1, type = "l", lwd = 2, col = "red",
ylim = range(path), xlab = "t", ylab = "Function value",
main = "Geodesic on unit Hilbert sphere")
#plotting
plot(time.grid, f1, type = "l", lwd = 2, col = "red",
xlab = "t", ylab = "Function value",
main = "Geodesic on unit Hilbert sphere")
lines(time.grid, f2, lwd = 2, col = "blue")
#rows are functions, columns are values of a function at a time point
#why is there a big matrix?
path <- problem2(p=f1, q=f2, n_steps = 11)
#plotting
plot(time.grid, f1, type = "l", lwd = 2, col = "red",
xlab = "t", ylab = "Function value",
main = "Geodesic on unit Hilbert sphere")
lines(time.grid, f2, lwd = 2, col = "blue")
mid_idx <- c(3, 6, 9)   # τ ≈ 0.2, 0.5, 0.8
cols <- c("orange", "green", "purple")
for (k in seq_along(mid_idx)) {
lines(time.grid, geo[mid_idx[k], ], col = cols[k], lwd = 1.5, lty = 2)
}
for (k in seq_along(mid_idx)) {
lines(time.grid, path[mid_idx[k], ], col = cols[k], lwd = 1.5, lty = 2)
}
legend("topright",
legend = c("f1 (τ=0)", "f2 (τ=1)",
"τ ≈ 0.2", "τ ≈ 0.5", "τ ≈ 0.8"),
col    = c("red","blue", cols), lwd = c(2,2,rep(1.5,3)),
lty    = c(1,1,rep(2,3)), bty = "n")
#plotting
plot(time.grid, f1, type = "l", lwd = 2, col = "red",
xlab = "t", ylab = "Function value",
main = "Geodesic on unit Hilbert sphere")
lines(time.grid, f2, lwd = 2, col = "blue")
problem2 <- function(p, q, n_steps = 1000){
#need to rescale the points
p <- p / sqrt(sum(p^2))
q <- q / sqrt(sum(q^2))
#for unit vectors a,b in Hilbert space, \theta = arccos({x,y})
angle <- acos(sum(p * q))
#create matrix to hold the path
#each row will be the path at t = n_step_i, and the length will
#correspond to the length of the vector
path <- matrix(NA, nrow = n_steps, ncol = length(p))
#computing path, assuming that the points are not antipodal, since then any path will do.
#I think we only compute the angle once?
for (i in 1:n_steps) {
#compute time, starting at 0
t <- (i-1) / (n_steps-1)
#the first term
term1 <- sin(angle*(1-t))*p
term2 <- sin(t*angle)*q
#path at time t
combined <- (term1+term2)/sin(angle)
path[i, ] <- combined
}
#return the path
return(path)
}
num.points = 25
time.grid <- seq(0,1,length.out = num.points)
#building points
f1 <- f_t(time.grid, a = 2, b = 5)
f2 <- f_t(time.grid, a = 2, b = 2)
#rows are functions, columns are values of a function at a time point
#why is there a big matrix?
path <- problem2(p=f1, q=f2, n_steps = 11)
View(path)
matplot(time.grid, t(path), type = "l", lty = 1, lwd = 1,
xlab = "t", ylab = "f(t)", main = "All geodesic waypoints (τ from 0→1)")
lines(time.grid, f1, lwd = 2, col = "red")
lines(time.grid, f2, lwd = 2, col = "blue")
legend("topright", legend = c("f1 (τ=0)","f2 (τ=1)"),
col = c("red","blue"), lwd = 2, bty = "n")
matplot(time.grid, t(path), type = "l", lty = 1, lwd = 1,
xlab = "t", ylab = "f(t)", main = "All geodesic waypoints (τ from 0→1)")
yr <- range(c(path, f1, f2))
matplot(time.grid, t(path), type = "l", lty = 1, lwd = 1,
xlab = "t", ylab = "f(t)",
main = "All geodesic waypoints (τ from 0→1)",
ylim = yr)
# now overlay endpoints
lines(time.grid, f1, lwd = 2, col = "red")
lines(time.grid, f2, lwd = 2, col = "blue")
legend("topright",
legend = c("f1 (τ=0)","f2 (τ=1)"),
col = c("red","blue"), lwd = 2, bty = "n")
matplot(time.grid, t(path), type = "l", lty = 1, lwd = 1,
xlab = "t", ylab = "f(t)",
main = "Geodesic Path from f1 to f2",
ylim = yr)
# now overlay endpoints
lines(time.grid, f1, lwd = 2, col = "red")
lines(time.grid, f2, lwd = 2, col = "blue")
legend("topright", legend = c("f1 (τ=0)","f2 (τ=1)"),
col = c("red","blue"), lwd = 2, bty = "n")
legend("topright", legend = c("f1","f2"),
col = c("red","blue"), lwd = 2)
matplot(time.grid, t(path), type = "l", lty = 1, lwd = 1,
xlab = "t", ylab = "f(t)",
main = "Geodesic Path from f1 to f2",
ylim = yr)
#endpoints
lines(time.grid, f1, lwd = 2, col = "red")
lines(time.grid, f2, lwd = 2, col = "blue")
legend("topright", legend = c("f1","f2"),
col = c("red","blue"), lwd = 2)
num.points = 500
time.grid <- seq(0,1,length.out = num.points)
#building points
f1 <- f_t(time.grid, a = 2, b = 5)
#building points
f1 <- f_t(time.grid, a = 2, b = 5)
f2 <- f_t(time.grid, a = 2, b = 2)
#rows are functions, columns are values of a function at a time point
#smooth function connecting f1 and f2?
path <- problem2(p=f1, q=f2, n_steps = 11)
yr <- range(c(path, f1, f2))
matplot(time.grid, t(path), type = "l", lty = 1, lwd = 1,
xlab = "t", ylab = "f(t)",
main = "Geodesic Path from f1 to f2",
ylim = yr)
#endpoints
lines(time.grid, f1, lwd = 2, col = "red")
lines(time.grid, f2, lwd = 2, col = "blue")
legend("topright", legend = c("f1","f2"),
col = c("red","blue"), lwd = 2)
#function for inverse exponential mapping
#returns tangent vector
inv_exp_mapping <- function(p,q){
#normalizing
p <- p / sqrt(sum(p^2))
q <- q / sqrt(sum(q^2))
#computing angle
angle <- acos(sum(p*q))
#formula for inverse exponential (logarithmic???) mapping
out <- (theta / sin(theta))*(q-cos(theta)*p)
return(out)
}
#function for exponential mapping
#returns tangent vector back to the sphere
exp_mapping <- function(p, v){
#scaling and normalizing
p <- p / sqrt(sum(p^2))
v_norm <- sqrt(sum(v^2))
#formula for exponential mapping
out <- (cos(v_norm)*p) + (sin(v_norm)*(v/v_norm))
return(out)
}
#computing inverse exponent of f2
v = inv_exp_mapping(f1, f2)
#function for inverse exponential mapping
#returns tangent vector
inv_exp_mapping <- function(p,q){
#normalizing
p <- p / sqrt(sum(p^2))
q <- q / sqrt(sum(q^2))
#computing angle
angle <- acos(sum(p*q))
#formula for inverse exponential (logarithmic???) mapping
out <- (angle / sin(angle))*(q-cos(angle)*p)
return(out)
}
#function for exponential mapping
#returns tangent vector back to the sphere
exp_mapping <- function(p, v){
#scaling and normalizing
p <- p / sqrt(sum(p^2))
v_norm <- sqrt(sum(v^2))
#formula for exponential mapping
out <- (cos(v_norm)*p) + (sin(v_norm)*(v/v_norm))
return(out)
}
#computing inverse exponent of f2
v = inv_exp_mapping(f1, f2)
exp(v) = exp_mapping(f1,v)
exp_v <- exp_mapping(f1,v)
p_unit <- unit(f1); q_unit <- unit(f2)
nrm  <- function(x) sqrt(sum(x^2))
ip   <- function(x, y) sum(x * y)
unit <- function(x)    x / nrm(x)
p_unit <- unit(f1); q_unit <- unit(f2)
theta  <- acos(ip(p_unit, q_unit))
cat("angle θ =", theta, "\n")
cat("||v|| (should equal θ) =", nrm(v), "\n")
cat("<p,v> (tangency, should be ~0) =", ip(p_unit, v), "\n")
cat("reconstruction error ||exp_p(v) - q|| =", nrm(f2_hat - q_unit), "\n")
cat("reconstruction error ||exp_p(v) - q|| =", nrm(exp_v - q_unit), "\n")
yr <- range(c(p_unit, q_unit, f2_hat))
yr <- range(c(p_unit, q_unit, exp_v))
plot(tgrid, p_unit, type="l", col="red", lwd=2, ylim=yr,
xlab="t", ylab="f(t)", main="Exp/Log on the unit Hilbert sphere")
yr <- range(c(p_unit, q_unit, exp_v))
plot(time.grid, p_unit, type="l", col="red", lwd=2, ylim=yr,
xlab="t", ylab="f(t)", main="Exp/Log on the unit Hilbert sphere")
lines(time.grid, q_unit,  lwd=2, col="blue")
lines(time.grid, exp_v,  lwd=2, col="darkgreen", lty=2)
legend("topright",
legend=c("p = f1", "q = f2", "exp_p(log_p(q))"),
col=c("red","blue","darkgreen"), lwd=2, lty=c(1,1,2), bty="n")
plot(time.grid, p_unit, type="l", col="red", lwd=2, ylim=yr,
xlab="t", ylab="f(t)", main="Exp/Log on the unit Hilbert sphere")
lines(time.grid, exp_v,  lwd=2, col="darkgreen", lty=2)
difference <- expv_v - f2
difference <- exp_v - f2
f2_unit <- f2/sqrt(sum(f2^2))
difference <- exp_v - f2_unit
sqrt(sum(difference^2))
difference <- exp_v - f2
sqrt(sum(difference^2))
difference <- exp_v*sqrt(sum(exp_v^2)) - f2
#rows are functions, columns are values of a function at a time point
#smooth function connecting f1 and f2?
path <- problem2(p=f1, q=f2, n_steps = 11)
yr <- range(c(path, f1, f2))
matplot(time.grid, t(path), type = "l", lty = 1, lwd = 1,
xlab = "t", ylab = "f(t)",
main = "Geodesic Path from f1 to f2",
ylim = yr)
#endpoints
lines(time.grid, f1, lwd = 2, col = "red")
lines(time.grid, f2, lwd = 2, col = "blue")
legend("topright", legend = c("f1","f2"),
col = c("red","blue"), lwd = 2)
library(R.matlab)
#problem 4
#loading in data for S2
S2.dat1 <- readMat("Datasets/HW2/Problem 4/S2DataFile1.mat")
View(S2.dat1)
S2.dat1[["x"]]
sim(S2.dat1)
sim(S2.dat1)
sim(S2.dat1$x)
dim(S2.dat1$x)
row_unit(S2.dat1$x)
rowSums(S2.dat1$x)
rowSums(t(S2.dat1$x))
#problem 4
#intrinsic mean and the Ferchet mean?
#loading in data for S2
S2.dat1 <- readMat("Datasets/HW2/Problem 4/S2DataFile1.mat")
dim(S2.dat1$x)
dat1.X <- S2.dat1$x
X <- t(dat1.X)
X*X
rowSums(X * X)
Xu <- X / rowSums(X * X)
Xu == X
X
Xu
# Round the matrices to 4 decimal places
# Check for equality
are_equal <- all(X == Xu)
# Print the result
print(paste("Matrices are equal to 4 decimal places:", are_equal))
# Round the matrices to 4 decimal places
# Check for equality
rounded_matrixA <- round(X, digits = 4)
rounded_matrixB <- round(Xu, digits = 4)
# Check for equality
are_equal <- all(rounded_matrixA == rounded_matrixB)
# Print the result
print(paste("Matrices are equal to 4 decimal places:", are_equal))
mu <- colMeans(Xu)
mu
sqrt(sum(mu * mu)
sqrt(sum(mu * mu))
sqrt(sum(mu * mu))
Xu <- X / rowSums(X * X)
mu <- colMeans(Xu)
mu
mu / sqrt(sum(mu * mu))
View(X)
