}
}
test <- dist.mat(funs = p5.f, t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
}
}
test <- dist.mat(funs = p5.f, t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
}
}
test <- dist.mat(funs = p5.f, t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = p5.f, t = as.vector(p5.t))
View(test)
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
#take arc cosine and fill upper and lower triangle matrices
print(inner.prod)
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = p5.f, t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = p5.f, t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
cat(inner.prod, "i")
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = p5.f, t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
cat(inner.prod, i)
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = p5.f, t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
cat(inner.prod, i)
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = as.matrix(p5.f), t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = as.matrix(p5.f), t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[2]
print(dt)
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = as.matrix(p5.f), t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- diff(t)[7]
print(dt)
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = as.matrix(p5.f), t = as.vector(p5.t))
dist.mat <- function(funs, t){
#get dimensions
n <- nrow(funs)
m <- ncol(funs)
dt <- t[2] - t[1]
#ordinarily would normalize each function, but they already are
#take square root of densities
sq.root <- matrix(0, n, m)
for (i in 1:n) {
for (j in 1:m) {
sq.root[i, j] <- sqrt(funs[i, j])
}
}
#need to get inner product and distances
dist <- matrix(0, n,n)
for (i in 1:n) {
for (j in i:n) {
inner.prod <- 0
for (k in 1:m){
inner.prod <- inner.prod + (sq.root[i,k]*sq.root[j,k])
}
inner.prod <- inner.prod*dt
#take arc cosine and fill upper and lower triangle matrices
d <- acos(inner.prod)
dist[i, j] <- d
dist[j, i] <- d
}
dist[i, i] <- 0
}
return(dist)
}
test <- dist.mat(funs = as.matrix(p5.f), t = as.vector(p5.t))
pairwise.dist.mat <- dist.mat(funs = as.matrix(p5.f), t = as.vector(p5.t))
#part 2, dendogram clustering
dend.cluster <- hclust(as.dist(pairwise.dist.mat), method = "average")
#plot
plot(hc, main = "Hierarchical Clustering of PDFs (Fisher–Rao)",
xlab = "", sub = "", ylab = "Fisher–Rao distance")
#plot
plot(dend.cluster, main = "Hierarchical Clustering of PDFs (Fisher–Rao)",
xlab = "", sub = "", ylab = "Fisher–Rao distance")
#part 2, dendogram clustering
dend.cluster <- hclust(as.dist(pairwise.dist.mat), method = "median")
#plot
plot(dend.cluster, main = "Hierarchical Clustering of PDFs (Fisher–Rao)",
xlab = "", sub = "", ylab = "Fisher–Rao distance")
#part 2, dendogram clustering
methods <- c("single", "complete", "average", "ward.D2", "median", "centroid")
par(mfrow = c(2, 3))
for (m in methods) {
hc <- hclust(as.dist(pairwise.dist.mat), method = m)
plot(hc, main = paste("Method:", m), xlab = "", ylab = "Distance", sub = "")
}
par(mfrow = c(1,1))
#part 3 and 4, generate MDS plot
hc <- hclust(as.dist(D), method = "average")
#part 3 and 4, generate MDS plot
hc <- hclust(as.dist(pairwise.dist.mat), method = "average")
#part 3 and 4, generate MDS plot
hc <- hclust(as.dist(pairwise.dist.mat), method = "average")
xy2 <- cmdscale(as.dist(D), k = 2)
xy2 <- cmdscale(as.dist(pairwise.dist.mat), k = 2)
plot(xy2, col = grp, pch = 19, xlab = "MDS-1", ylab = "MDS-2",
main = "MDS colored by cluster")
k <- 3
grp <- cutree(hc, k = k)
xy2 <- cmdscale(as.dist(pairwise.dist.mat), k = 2)
plot(xy2, col = grp, pch = 19, xlab = "MDS-1", ylab = "MDS-2",
main = "MDS colored by cluster")
text(xy2, labels = paste0("g", seq_along(grp)), pos = 3, cex = 0.8)
legend("topright", legend = levels(factor(grp)), col = 1:length(unique(grp)), pch = 19)
#function to build test functions
f_t <- function(t, a, b){
part1 <- t^(a-1)
part2 <- part1*(1-t)^(b-1)
part3 <- part2/beta(a,b)
part4 <- sqrt(part3)
#return
return(part4)
}
problem2 <- function(p, q, n_steps = 1000){
#need to rescale the points
p <- p / sqrt(sum(p^2))
q <- q / sqrt(sum(q^2))
#for unit vectors a,b in Hilbert space, \theta = arccos({x,y})
angle <- acos(sum(p * q))
#create matrix to hold the path
#each row will be the path at t = n_step_i, and the length will
#correspond to the length of the vector
path <- matrix(NA, nrow = n_steps, ncol = length(p))
#computing path, assuming that the points are not antipodal, since then any path will do.
#I think we only compute the angle once?
for (i in 1:n_steps) {
#compute time, starting at 0
t <- (i-1) / (n_steps-1)
#the first term
term1 <- sin(angle*(1-t))*p
term2 <- sin(t*angle)*q
#path at time t
combined <- (term1+term2)/sin(angle)
path[i, ] <- combined
}
#return the path
return(path)
}
num.points = 500
time.grid <- seq(0,1,length.out = num.points)
#building points
f1 <- f_t(time.grid, a = 2, b = 5)
f2 <- f_t(time.grid, a = 2, b = 2)
#rows are functions, columns are values of a function at a time point
#smooth function connecting f1 and f2?
path <- problem2(p=f1, q=f2, n_steps = 11)
yr <- range(c(path, f1, f2))
matplot(time.grid, t(path), type = "l", lty = 1, lwd = 1,
xlab = "t", ylab = "f(t)",
main = "Geodesic Path from f1 to f2",
ylim = yr)
#endpoints
lines(time.grid, f1, lwd = 2, col = "red")
lines(time.grid, f2, lwd = 2, col = "blue")
legend("topright", legend = c("f1","f2"),
col = c("red","blue"), lwd = 2)
#function for inverse exponential mapping
#returns tangent vector
inv_exp_mapping <- function(p,q){
#normalizing
p <- p / sqrt(sum(p^2))
q <- q / sqrt(sum(q^2))
#computing angle
angle <- acos(sum(p*q))
#formula for inverse exponential (logarithmic???) mapping
out <- (angle / sin(angle))*(q-cos(angle)*p)
return(out)
}
#function for exponential mapping
#returns tangent vector back to the sphere
exp_mapping <- function(p, v){
#scaling and normalizing
p <- p / sqrt(sum(p^2))
v_norm <- sqrt(sum(v^2))
#formula for exponential mapping
out <- (cos(v_norm)*p) + (sin(v_norm)*(v/v_norm))
return(out)
}
#computing inverse exponent of f2 and then compute exp(v)
v = inv_exp_mapping(f1, f2)
exp_v <- exp_mapping(f1,v)
inner_prod <- sum(exp_v * f2)        # cosine of the geodesic angle
angle <- acos(inner_prod)            # geodesic distance
l2_diff <- sqrt(sum((exp_v - f2)^2)) # Euclidean distance
cat("Inner product:", inner_prod, "\n")
cat("Geodesic distance (radians):", angle, "\n")
cat("L2 difference:", l2_diff, "\n")
