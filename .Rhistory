#loading in data
Fmat <- data$f0
t <- data$t
y <- data$y0
#basis function (B splines)
B <- bs(t, df=K, intercept = TRUE)
#need to discretize
dt <- diff(t)[1]
#projecting functions onto basis space, with the dt added in
X <- Fmat %*% (B*dt)
#Ridge
ridge.fit <- ridge_fitting(X = X, y = y, B = B, lambda = 5)
}
test <- prob6.fun(data = prob6.dat, K = 5)
#functions to fit model with both ridge (penalized model) and unpenalized model
ridge_fitting <- function(X, y, B, lambda){
p <- ncol(X)
XtX <- crossprod(X)
Xty <- crossprod(X, y)
theta <- solve(XtX + lambda * diag(p), Xty)
#predictions
beta_hat <- as.vector(B %*% theta)
#RSS values
A <- solve(XtX + lambda * diag(p))
yhat <- as.vector(X %*% theta)
rss  <- sum((y - yhat)^2)
S  <- X %*% A %*% t(X)
df_lam <- sum(diag(S))
print(df_lam)
sigma2_hat <- rss / (n - df_lam)
return(theta)
}
prob6.fun <- function(data, K){
#loading in data
Fmat <- data$f0
t <- data$t
y <- data$y0
#basis function (B splines)
B <- bs(t, df=K, intercept = TRUE)
#need to discretize
dt <- diff(t)[1]
#projecting functions onto basis space, with the dt added in
X <- Fmat %*% (B*dt)
#Ridge
ridge.fit <- ridge_fitting(X = X, y = y, B = B, lambda = 5)
}
test <- prob6.fun(data = prob6.dat, K = 5)
#functions to fit model with both ridge (penalized model) and unpenalized model
ridge_fitting <- function(X, y, B, lambda){
p <- ncol(X)
print(p)
XtX <- crossprod(X)
Xty <- crossprod(X, y)
theta <- solve(XtX + lambda * diag(p), Xty)
#predictions
beta_hat <- as.vector(B %*% theta)
#RSS values
A <- solve(XtX + lambda * diag(p))
yhat <- as.vector(X %*% theta)
rss  <- sum((y - yhat)^2)
S  <- X %*% A %*% t(X)
df_lam <- sum(diag(S))
sigma2_hat <- rss / (n - df_lam)
return(theta)
}
ols_fitting <- function(x, y){
p <- ncol(X)
XtX <- crossprod(X)
Xty <- crossprod(X, y)
theta <- solve(XtX, Xty)
return(theta)
}
prob6.fun <- function(data, K){
#loading in data
Fmat <- data$f0
t <- data$t
y <- data$y0
#basis function (B splines)
B <- bs(t, df=K, intercept = TRUE)
#need to discretize
dt <- diff(t)[1]
#projecting functions onto basis space, with the dt added in
X <- Fmat %*% (B*dt)
#Ridge
ridge.fit <- ridge_fitting(X = X, y = y, B = B, lambda = 5)
}
test <- prob6.fun(data = prob6.dat, K = 5)
#functions to fit model with both ridge (penalized model) and unpenalized model
ridge_fitting <- function(X, y, B, lambda){
p <- ncol(X)
XtX <- crossprod(X)
print(XtX)
Xty <- crossprod(X, y)
theta <- solve(XtX + lambda * diag(p), Xty)
#predictions
beta_hat <- as.vector(B %*% theta)
#RSS values
A <- solve(XtX + lambda * diag(p))
yhat <- as.vector(X %*% theta)
rss  <- sum((y - yhat)^2)
S  <- X %*% A %*% t(X)
df_lam <- sum(diag(S))
sigma2_hat <- rss / (n - df_lam)
return(theta)
}
ols_fitting <- function(x, y){
p <- ncol(X)
XtX <- crossprod(X)
Xty <- crossprod(X, y)
theta <- solve(XtX, Xty)
return(theta)
}
prob6.fun <- function(data, K){
#loading in data
Fmat <- data$f0
t <- data$t
y <- data$y0
#basis function (B splines)
B <- bs(t, df=K, intercept = TRUE)
#need to discretize
dt <- diff(t)[1]
#projecting functions onto basis space, with the dt added in
X <- Fmat %*% (B*dt)
#Ridge
ridge.fit <- ridge_fitting(X = X, y = y, B = B, lambda = 5)
}
test <- prob6.fun(data = prob6.dat, K = 5)
#Problem 6
prob6.dat <- readMat("Datasets/HW1/Problem 6/RegressionDataFile.mat")
#set up data
Fmat <- prob6.dat$f0
t <- prob6.dat$t
y <- prob6.dat$y0
dt <- diff(t)[1]
#basis (B-splines) and design matrix
K <- 10
B  <- bs(t, df = K, intercept = TRUE)
dt <- diff(t)[1]
X  <- Fmat %*% (B*dt)
#OLS
fit_ols <- lm(y ~ X - 1)
prob6.dat <- readMat("Datasets/HW1/Problem 6/RegressionDataFile.mat")
#set up data
Fmat <- prob6.dat$f0
t <- prob6.dat$t
y <- prob6.dat$y0
#basis (B-splines) and design matrix
K <- 10
B  <- bs(t, df = K, intercept = TRUE)
dt <- diff(t)[1]
X  <- Fmat %*% (B*dt)
#OLS
fit_ols <- lm(y ~ X - 1)
library(glmnet)
cat("dim(Fmat) = ", paste(dim(Fmat), collapse=" x "), "\n")
cat("length(t) = ", length(t), "\n")
cat("length(y) = ", length(y), "\n")
cat("anyNA(Fmat): ", anyNA(Fmat), "\n")
cat("anyNA(t): ", anyNA(t), "\n")
cat("anyNA(y): ", anyNA(y), "\n")
#OLS
fit_ols <- lm(y ~ X)
y <- as.numeric(prob6.dat$y0)
#basis (B-splines) and design matrix
K <- 10
B  <- bs(t, df = K, intercept = TRUE)
dt <- diff(t)[1]
X  <- Fmat %*% (B*dt)
cat("dim(Fmat) = ", paste(dim(Fmat), collapse=" x "), "\n")
cat("length(t) = ", length(t), "\n")
cat("length(y) = ", length(y), "\n")
cat("anyNA(Fmat): ", anyNA(Fmat), "\n")
cat("anyNA(t): ", anyNA(t), "\n")
cat("anyNA(y): ", anyNA(y), "\n")
#OLS
fit_ols <- lm(y ~ X)
#OLS
fit_ols <- lm(y ~ x)
#basis (B-splines) and design matrix
K <- 5
B  <- bs(t, df = K, intercept = TRUE)
dt <- diff(t)[1]
X  <- Fmat %*% (B*dt)
#Problem 6
prob6.dat <- readMat("Datasets/HW1/Problem 6/RegressionDataFile.mat")
#set up data
Fmat <- prob6.dat$f0
t <- prob6.dat$t
y <- prob6.dat$y0
#basis (B-splines) and design matrix
K <- 5
B  <- bs(t, df = K, intercept = TRUE)
dt <- diff(t)[1]
X  <- Fmat %*% (B*dt)
#OLS
fit_ols <- lm(y ~ x)
#OLS
fit_ols <- lm(y ~ X)
X  <- Fmat %*% (B)
X  <- Fmat %*% (B)*dt
dt <- diff(t)[1]
dt <- diff(t)
View(prob6.dat)
#set up data
Fmat <- prob6.dat$f0
t <- as.numeric(prob6.dat$t)
y <- prob6.dat$y0
#basis (B-splines) and design matrix
K <- 5
B  <- bs(t, df = K, intercept = TRUE)
dt <- diff(t)
#OLS
fit_ols <- lm(y ~ X)
B*dt
dt <- diff(t)[1]
#basis (B-splines) and design matrix
K <- 5
B  <- bs(t, df = K, intercept = TRUE)
dt <- diff(t)[1]
X  <- Fmat %*% (B*dt)
#OLS
fit_ols <- lm(y ~ X)
summary(fit_ols)
#OLS
fit_ols <- lm(y ~ X -1)
summary(fit_ols)
beta_hat_ols <- coef(fit_ols)
beta_fun_ols <- as.vector(B %*% beta_hat_ols)
#ridge (penalized)
lambda_grid <- c(0.01, 0.1, 1, 10)
fit_ridge <- glmnet(
x = X, y = y,
alpha = 0,
lambda = lambda_grid,
intercept = FALSE,
standardize = FALSE
)
ridge_curves <- lapply(lambda_grid, function(lam) {
theta <- as.numeric(coef(fit_ridge, s = lam))[-1]   # drop intercept
beta_fun <- as.vector(B %*% theta)
data.frame(t = t, beta = beta_fun,
method = paste0("Ridge λ=", lam))
})
df_ols <- data.frame(t = t, beta = beta_fun_ols, method = "OLS")
df_all <- rbind(df_ols, do.call(rbind, ridge_curves))
ggplot(df_all, aes(x = t, y = beta, color = method)) +
geom_line(linewidth = 1) +
labs(title = "Scalar-on-Function Regression: OLS vs Ridge",
y = expression(beta(t)), x = "t") +
theme_minimal(base_size = 14)
#compare RSS
rss_ols <- sum(resid(fit_ols)^2)
rss_ridge <- sapply(lambda_grid, function(lam) {
theta <- as.numeric(coef(fit_ridge, s = lam))[-1]
yhat  <- as.vector(X %*% theta)
sum((y - yhat)^2)
})
data.frame(
Method = c("OLS", paste0("Ridge λ=", lambda_grid)),
RSS = c(rss_ols, rss_ridge)
)
#get pointwise confidence band
n  <- nrow(X); p <- ncol(X)
XtX <- crossprod(X)
rss_ols <- sum(resid(fit_ols)^2)
df_res  <- n - p
sigma2  <- rss_ols / df_res
Vtheta   <- sigma2 * solve(XtX)
BV       <- B %*% Vtheta
se_beta  <- sqrt(rowSums(BV * B))
crit     <- qt(0.975, df = df_res)
df_ols_band <- data.frame(
t = t,
beta = beta_fun_ols,
lo = beta_fun_ols - crit * se_beta,
hi = beta_fun_ols + crit * se_beta,
method = "OLS"
)
# Plot OLS with band
ggplot(df_ols_band, aes(x = t, y = beta)) +
geom_ribbon(aes(ymin = lo, ymax = hi), fill = "skyblue", alpha = 0.2) +
geom_line(linewidth = 1, color = "steelblue") +
labs(title = expression(OLS:~hat(beta)(t)~"with 95% bands"),
y = expression(beta(t)), x = "t") +
theme_minimal(base_size = 14)
ridge_band_cf <- function(X, y, B, t, lambda) {
n <- nrow(X); p <- ncol(X)
XtX <- crossprod(X); Xty <- crossprod(X, y)
A   <- solve(XtX + lambda * diag(p))
theta <- A %*% Xty
# fitteds & RSS
yhat <- as.vector(X %*% theta)
rss  <- sum((y - yhat)^2)
# smoother matrix trace for df(lambda)
S <- X %*% A %*% t(X)
df_lam <- sum(diag(S))
sigma2 <- rss / max(1, (n - df_lam))
# Var(theta) = sigma2 * A XtX A ; propagate to beta(t)
Vtheta  <- sigma2 * A %*% XtX %*% A
BV      <- B %*% Vtheta
beta    <- as.vector(B %*% theta)
se_beta <- sqrt(rowSums(BV * B))
crit <- qt(0.975, df = max(1, floor(n - df_lam)))
data.frame(
t = t,
beta = beta,
lo = beta - crit * se_beta,
hi = beta + crit * se_beta,
method = paste0("Ridge λ=", lambda)
)
}
# Build ridge bands for your grid
ridge_bands <- do.call(rbind, lapply(lambda_grid, function(lam) {
ridge_band_cf(X, y, B, t, lam)
}))
# Combine with OLS band and plot
df_all_bands <- rbind(df_ols_band, ridge_bands)
ggplot(df_all_bands, aes(x = t, y = beta, color = method, fill = method)) +
geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.18, color = NA) +
geom_line(linewidth = 1) +
labs(title = expression(hat(beta)(t)~": OLS vs Ridge (pointwise 95% bands)"),
y = expression(beta(t)), x = "t") +
theme_minimal(base_size = 14) +
guides(fill = "none")
#plotting the functional data we have
df_fun <- data.frame(
t = rep(t, each = nrow(Fmat)),
curve = factor(rep(seq_len(n), times = ncol(Fmat))),
value = as.vector(Fmat)
)
ggplot(df_fun, aes(x = t, y = value, group = curve)) +
geom_line(alpha = 0.35) +
labs(title = "Original functional predictors F_i(t)",
x = "t", y = "F_i(t)") +
theme_minimal(base_size = 14)
plot(t, y)
plot(y)
ggplot(df_all, aes(x = t, y = beta, color = method)) +
geom_line(linewidth = 1) +
labs(title = "Scalar-on-Function Regression: OLS vs Ridge",
y = expression(beta(t)), x = "t") +
theme_minimal(base_size = 14)
prob6.dat <- readMat("Datasets/HW1/Problem 6/RegressionDataFile.mat")
#set up data
Fmat <- prob6.dat$f0
t <- as.numeric(prob6.dat$t)
y <- prob6.dat$y0
#plotting the functional data we have
df_fun <- data.frame(
t = rep(t, each = nrow(Fmat)),
curve = factor(rep(seq_len(n), times = ncol(Fmat))),
value = as.vector(Fmat)
)
ggplot(df_fun, aes(x = t, y = value, group = curve)) +
geom_line(alpha = 0.35) +
labs(title = "Original functional predictors F_i(t)",
x = "t", y = "F_i(t)") +
theme_minimal(base_size = 14)
#basis (B-splines) and design matrix
K <- 5
B  <- bs(t, df = K, intercept = TRUE)
dt <- diff(t)[1]
X  <- Fmat %*% (B*dt)
#OLS fit
fit_ols <- lm(y ~ X -1)
beta_hat_ols <- coef(fit_ols)
beta_fun_ols <- as.vector(B %*% beta_hat_ols)
#ridge (penalized)
lambda_grid <- c(0.01, 0.1, 1, 10)
fit_ridge <- glmnet(
x = X, y = y,
alpha = 0,
lambda = lambda_grid,
intercept = FALSE,
standardize = FALSE
)
#ridge coefficient curves
ridge_curves <- lapply(lambda_grid, function(lam) {
theta <- as.numeric(coef(fit_ridge, s = lam))[-1]
beta_fun <- as.vector(B %*% theta)
data.frame(t = t, beta = beta_fun,
method = paste0("Ridge λ=", lam))
})
df_ols <- data.frame(t = t, beta = beta_fun_ols, method = "OLS")
df_all <- rbind(df_ols, do.call(rbind, ridge_curves))
ggplot(df_all, aes(x = t, y = beta, color = method)) +
geom_line(linewidth = 1) +
labs(title = "Scalar-on-Function Regression: OLS vs Ridge",
y = expression(beta(t)), x = "t") +
theme_minimal(base_size = 14)
rss_ridge <- sapply(lambda_grid, function(lam) {
theta <- as.numeric(coef(fit_ridge, s = lam))[-1]
yhat  <- as.vector(X %*% theta)
sum((y - yhat)^2)
})
data.frame(
Method = c("OLS", paste0("Ridge λ=", lambda_grid)),
RSS = c(rss_ols, rss_ridge)
)
data.frame(
Method = c("OLS", paste0("Ridge", expression(lambda), " =", lambda_grid)),
RSS = c(rss_ols, rss_ridge)
)
data.frame(
Method = c("OLS", paste0("Ridge", expression(\lambda), " =", lambda_grid)),
data.frame(
Method = c("OLS", paste0("Ridge (lambda)=", lambda_grid)),
RSS = c(rss_ols, rss_ridge)
)
#function for OLs bands
ols_bands_cf <- function(X, y, B, t, level = 0.95) {
n <- nrow(X)
p <- ncol(X)
fit <- lm.fit(x = X, y = y)
theta <- coef(fit)
beta_hat <- as.vector(B %*% theta)
#variance
XtX <- crossprod(X)
rss <- sum((y - as.vector(X %*% theta))^2)
df <- n - p
sigma2 <- rss / df
Vtheta <- sigma2 * solve(XtX)
BV <- B %*% Vtheta
#get diag of the covariance matrix and take square root
se_beta <- sqrt(diag(B %*% Vtheta %*% t(B)))
#finding critical t value
alpha <- 1 - level
crit  <- qt(1 - alpha/2, df = df)
#returning data
data.frame(
t = as.numeric(t),
beta = beta_hat,
lo = beta_hat - crit * se_beta,
hi = beta_hat + crit * se_beta,
method = "OLS"
)
}
#function for residual bootstrap
ridge_bands <- function(X, y, B, t, lambda, Bboot = 500, level = 0.95){
n <- nrow(X)
fit0 <- glmnet(x = X, y = y, alpha = 0, lambda = lambda,
intercept = FALSE, standardize = FALSE)
theta_hat <- as.numeric(coef(fit0, s = lambda))[-1]
beta_hat  <- as.vector(B %*% theta_hat)
}
#call everything
df_ols_band <- ols_bands_cf(X, y, B, t, level = 0.95)
#ridge bootstrap
ridge_boot_list <- lapply(lambda.grid, function(lam) {
ridge_bands_boot(X, y, B, t, lambda = lam, Bboot = 500, level = 0.95)
})
#ridge bootstrap
ridge_boot_list <- lapply(lambda_grid, function(lam) {
ridge_bands_boot(X, y, B, t, lambda = lam, Bboot = 500, level = 0.95)
})
#ridge bootstrap
ridge_boot_list <- lapply(lambda_grid, function(lam) {
ridge_bands(X, y, B, t, lambda = lam, Bboot = 500, level = 0.95)
})
df_ridge_band <- do.call(rbind, ridge_boot_list)
#plotting everything
df_all <- rbind(df_ols_band, df_ridge_band)
View(df_ridge_band)
#function for residual bootstrap
#following setup here: https://faculty.washington.edu/yenchic/17Sp_403/Lec6-bootstrap_reg.pdf
ridge_bands <- function(X, y, B, t, lambda, Bboot = 500, level = 0.95){
n <- nrow(X)
#running ridge fit #1 and getting predicted coefficient values
fit <- glmnet(x = X, y = y, alpha = 0, lambda = lambda,
intercept = FALSE, standardize = FALSE)
theta_hat <- as.numeric(coef(fit, s = lambda))[-1]
beta_hat  <- as.vector(B %*% theta_hat)
#residual portion
yhat  <- as.vector(X %*% theta_hat)
resid <- y - yhat
#bootstrap portion
boot_mat <- matrix(NA_real_, nrow = nrow(B), ncol = Bboot)
for (b in seq_len(Bboot)) {
e_star <- sample(resid, size = n, replace = TRUE)
y_star <- yhat + e_star
fit_b <- glmnet(x = X, y = y_star, alpha = 0, lambda = lambda,
intercept = FALSE, standardize = FALSE)
theta_star <- as.numeric(coef(fit_b, s = lambda))[-1]
boot_mat[, b] <- as.vector(B %*% theta_star)
}
#critical t value and create interval estimate
alpha <- 1 - level
lo <- apply(boot_mat, 1, quantile, probs = alpha/2, na.rm = TRUE)
hi <- apply(boot_mat, 1, quantile, probs = 1 - alpha/2, na.rm = TRUE)
#pass dataframe
data.frame(
t = t,
beta = beta_hat, lo = lo, hi = hi,
method = paste0("Ridge (lambda=", lambda, ")")
)
}
#call everything
df_ols_band <- ols_bands_cf(X, y, B, t, level = 0.95)
#ridge bootstrap
ridge_boot_list <- lapply(lambda_grid, function(lam) {
ridge_bands(X, y, B, t, lambda = lam, Bboot = 500, level = 0.95)
})
df_ridge_band <- do.call(rbind, ridge_boot_list)
#plotting everything
df_all <- rbind(df_ols_band, df_ridge_band)
ggplot(df_all, aes(x = t, y = beta, color = method, fill = method)) +
geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.18, color = NA) +
geom_line(linewidth = 1) +
labs(title = expression(hat(beta)(t)~": OLS (closed-form) vs Ridge (bootstrap)"),
y = expression(beta(t)), x = "t") +
theme_minimal(base_size = 14) +
guides(fill = "none")
